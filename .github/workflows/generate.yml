name: Main Workflow

permissions:
  actions: write
  contents: write
  statuses: write
  pull-requests: write

on:
  workflow_dispatch:
    inputs:
      dispatchId:
        type: string
      depth:
        type: number
        default: 1
      max-depth:
        type: number
        default: 1
      previous-file:
        type: string
        description: Previous test yaml file to use as a base

jobs:
  match-dispatchId:
    if: ${{ inputs.dispatchId }}
    runs-on: [ubuntu-latest]
    steps:
      - id: dispatch-id
        name: dispatchId:${{ inputs.dispatchId }}
        run: echo "💁 The dispatch ID is ${{ github.event.inputs.dispatchId }}"

  generate-exploratory:
    needs: match-dispatchId
    uses: ./.github/workflows/generate-exploratory.yml
    with:
      depth: ${{ fromJson(inputs.depth) }}
      max-depth: ${{ fromJson(inputs.max-depth) }}
      website-url: ${{ vars.TESTDRIVER_WEBSITE }}
      base-branch: ${{ github.ref_name }}
      previous-file: ${{ inputs.previous-file }}
    secrets:
      TESTDRIVER_API_KEY: ${{ secrets.TESTDRIVER_API_KEY }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      LOGIN_USERNAME: ${{ secrets.LOGIN_USERNAME }}
      LOGIN_PASSWORD: ${{ secrets.LOGIN_PASSWORD }}

  generate-regression:
    needs: generate-exploratory
    uses: ./.github/workflows/generate-regressions.yml
    with:
      depth: ${{ fromJson(inputs.depth) }}
      max-depth: ${{ fromJson(inputs.max-depth) }}
      website-url: ${{ vars.TESTDRIVER_WEBSITE }}
      base-branch: ${{ needs.generate-exploratory.outputs.pr-branch }}
    secrets:
      TESTDRIVER_API_KEY: ${{ secrets.TESTDRIVER_API_KEY }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  finalize:
    name: Finalize
    needs: generate-regression
    runs-on: ubuntu-latest
    steps:
      - id: create-dispatch-ids
        name: Create Dispatch IDs
        uses: actions/github-script@v6
        env:
          RESULTS: ${{ needs.generate-regression.outputs.results }}
          DEPTH: ${{ inputs.depth }}
          MAX_DEPTH: ${{ inputs.max-depth }}
        with:
          script: |
            const results = [];
            for (const item of JSON.parse(process.env.RESULTS)) {
              // Check if branch exists
              const branchExists = await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: item.branch
              })
                .then(()=>true)
                .catch(()=>false)
              
              if(!branchExists) {
                console.log(`Branch ${item.branch} does not exist, skipping it`);
                continue              
              }
                
              item.depth = parseInt(process.env.DEPTH);
              item.maxDepth = parseInt(process.env.MAX_DEPTH);
              if(item.depth < item.maxDepth) {
                item.dispatchId = Math.random().toString(36).substring(2, 15);
              }
              results.push(item);
            }
            return results;

      - id: trigger-next-workflows
        name: Trigger Next Workflows
        if: ${{ inputs.depth != inputs.max-depth }}
        uses: actions/github-script@v6
        env:
          RESULTS: ${{ steps.create-dispatch-ids.outputs.result }}
          TOKEN: ${{ secrets.GH_PAT_TOKEN || secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        with:
          retries: 5
          retry-exempt-status-codes: 401,403
          script: |
            const dispatched = [];
            for (const item of JSON.parse(process.env.RESULTS)) {
              console.log(`Dispatching workflow for branch: ${item.branch}`);
              const success = await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'generate.yml',
                ref: item.branch,
                inputs: {
                  dispatchId: item.dispatchId,
                  depth: `${item.depth + 1}`,
                  "max-depth": `${item.maxDepth}`,
                  "previous-file": item.filename,
                }
              })
                .then(() => true)
                .catch(() => false)

              console.log(`Success: ${success}`);

              if(success){
                dispatched.push(item);
              }
            }
            return dispatched;

      - id: save-results
        uses: actions/github-script@v6
        env:
          RESULTS: ${{ steps.trigger-next-workflows.outputs.result || steps.create-dispatch-ids.outputs.result }}
        with:
          script: |
            require('fs').writeFileSync('results.json', process.env.RESULTS);

      - name: Setup Node
        if: ${{ inputs.depth == '1' && inputs.max-depth != '1' }}
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        if: ${{ inputs.depth == '1' && inputs.max-depth != '1' }}
        run: npm install uzip

      - name: Wait for all workflows to complete
        if: ${{ inputs.depth == '1' && inputs.max-depth != '1' }}
        uses: actions/github-script@v6
        env:
          DISPATCHED_WORKFLOWS: ${{ steps.trigger-next-workflows.outputs.result }}
          TOKEN: ${{ secrets.GH_PAT_TOKEN || secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          RUN_ID: ${{ github.run_id }}
        with:
          result-encoding: string
          retries: 5
          retry-exempt-status-codes: 401,403          
          script: |
            const UZip = require('uzip');

            const previousData = JSON.parse(process.env.DISPATCHED_WORKFLOWS);
            const dispatchIds = previousData.map((item) => item.dispatchId);
            const runsMap = new Map();
            const currentRunId = parseInt(process.env.RUN_ID);

            const getMatchedRuns = () => [...runsMap.values()].filter((run) => run?.dispatchId);
            const getCompletedMatchedRuns = () => getMatchedRuns().filter((run) => run.conclusion !== null);

            const minifyRun = (run) => ({
              id: run.id,
              branch: run.head_branch,
              status: run.status,
              conclusion: run.conclusion,
              pullRequests: run.pull_requests,
            });

            const listWorkflows = async () => {
              let page = 1;
              const set = new Set();
              const allRuns = [];

              while (true) {
                const { data } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'generate.yml',
                  event: 'workflow_dispatch',
                  per_page: 100,
                  page: page,
                });

                const runs = data.workflow_runs;
                if (runs.length === 0) break;

                runs
                  .filter((run) => {
                    if (set.has(run.id)) {
                      return false;
                    }
                    set.add(run.id);
                    return true;
                  })
                  .forEach((run) => {
                    allRuns.push(run);
                  });

                if (runs.length < 100) break;
                page++;
              }

              return allRuns.reverse().filter((run) => run.id !== currentRunId);
            };

            const listWorkflowJobs = async (runId) =>
              await github.rest.actions
                .listJobsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId,
                })
                .then(({ data: { jobs } }) => jobs);

            const getWorkflowRun = async (runId) => {
              const { data } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId,
              });

              return data;
            };

            const getResult = async (runId) => {
              const {
                data: {
                  artifacts: [artifact],
                },
              } = await github.rest.actions.listWorkflowRunArtifacts({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId,
                name: 'results.json',
              });

              if (!artifact) {
                return null;
              }

              const downloaded = await github.rest.actions.downloadArtifact({
                artifact_id: artifact.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                archive_format: 'zip',
              });

              let { 'results.json': file } = UZip.parse(downloaded.data);
              const results = new TextDecoder().decode(file);

              return JSON.parse(results);
            };

            const currentRun = await getWorkflowRun(currentRunId);
            runsMap.set(currentRunId, { results: previousData, ...minifyRun(currentRun) });
            while (getCompletedMatchedRuns().length < dispatchIds.length) {
              await new Promise((resolve) => setTimeout(resolve, 10000));

              const startedRuns = getMatchedRuns();
              const completedRuns = getCompletedMatchedRuns();

              console.log(`${startedRuns.length}/${dispatchIds.length} workflows started...`);
              console.log(`${completedRuns.length}/${startedRuns.length} workflows completed...`);

              const runs = await listWorkflows();

              for (let run of runs) {
                const localRun = runsMap.get(run.id);
                if (localRun) {
                  const { dispatchId, results } = localRun;
                  // Update the run with the new data
                  runsMap.set(run.id, { dispatchId, results, ...minifyRun(run) });
                } else {
                  const jobs = await listWorkflowJobs(run.id);
                  const dispatchId = jobs
                    .find((job) => job.name === 'match-dispatchId')
                    ?.steps.find((step) => step.name.startsWith('dispatchId:'))
                    ?.name.split('dispatchId:')[1];
                  // Add the run
                  runsMap.set(run.id, { dispatchId, ...minifyRun(run) });
                }

                run = runsMap.get(run.id);

                if (run.dispatchId && run.conclusion && !run.results) {
                  const runResults = await getResult(run.id);
                  console.log(
                    'dispatchId:',
                    run.dispatchId,
                    `completed, ${(runResults && Object.values(runResults).length) || 'no'} results found`
                  );
                  if (runResults) {
                    run.results = runResults;
                    runsMap.set(run.id, run);
                    const newDispatchIds = runResults.map((item) => item.dispatchId).filter(Boolean);
                    dispatchIds.push(...newDispatchIds);
                    if (newDispatchIds.length) {
                      console.log(`Added ${newDispatchIds.length} new workflow runs to the watchlist`);
                    }
                  }
                }
              }
            }

            const results = JSON.stringify(
              { previousData, results: Object.fromEntries([...runsMap.entries()]) },
              null,
              2
            );
            console.log(results);
            require('fs').writeFileSync('results.json', results);

      - name: delete-previous-results
        if: ${{ inputs.depth == '1' && inputs.max-depth != '1' }}
        uses: actions/github-script@v7
        with:
          script: |
            const [artifact] = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ toJson(github.run_id) }},
              name: "results.json",
            }).then(r => r.data.artifacts);
            
            await github.rest.actions.deleteArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: artifact.id
            });
            

      - id: save-final-results
        uses: actions/upload-artifact@v4
        with:
          name: results.json
          path: results.json
